Introduction
Building a networked shared disk system for Atari 8-bit XL/XE computers requires blending vintage SIO/PIO interfaces with modern microcontrollers. Fortunately, several projects have paved the way by emulating Atari disk drives or providing Wi-Fi connectivity using Arduino, ESP8266, and ESP32. This report surveys these projects – from FujiNet’s Wi-Fi multi-device emulator to Astarta-ESP32’s SD-based drive emulator, and classics like SIO2SD, SDrive-MAX, and SIO2IDE. We examine their hardware designs, firmware strategies, and networking approaches, extracting insights to design an ESP32-based central storage hub that can serve multiple Atari machines simultaneously. Key technical considerations – level shifting 5V Atari signals, handling ATR disk images (with 16MB size limits), coordinating multi-computer access, and choosing suitable storage media – are discussed with references to schematics and source code. Finally, a step-by-step implementation roadmap is provided, outlining how to build the Arduino Nano-based Atari interfaces and the central ESP32 hub for a multi-Atari shared disk network.
Relevant Projects & Implementations
FujiNet (Atari 8-bit Wi-Fi Adapter & Multi-Device Emulator): The FujiNet project is a modern, open-source peripheral for Atari 8-bit computers built around an ESP32. It began as a simple Wi-Fi modem but evolved into a “super peripheral emulator” that simultaneously emulates multiple device types – disk drives, modems (R: devices), printers, cassette, and even a network interface​
TINKERDIFFERENT.COM
​
CTRL-ALT-REES.COM
. FujiNet attaches to the Atari’s SIO port and uses the ESP32 to handle networking and device emulation. Notably, it can present up to 8 virtual disk drives (D1:–D8:) to the Atari at once, alongside other peripherals​
CTRL-ALT-REES.COM
. The ESP32’s Wi-Fi allows FujiNet to fetch disk images from the internet or a local server (using protocols like TNFS), and it offloads heavy network protocols (TCP/IP, Telnet, SSL) so the Atari only sees simple SIO commands​
TINKERDIFFERENT.COM
. The entire FujiNet project is open-source (hardware schematics and firmware are on GitHub​
TINKERDIFFERENT.COM
), making it an invaluable reference for both hardware interfacing and software. Its success across Atari and other 8-bit platforms (C64, Coleco Adam, etc.) demonstrates the viability of using a microcontroller (ESP32) to bridge old computers to modern networks. For our design, FujiNet provides inspiration on multi-device emulation and network file access. It shows that one ESP32 can emulate numerous SIO devices concurrently, and that Wi-Fi networking can effectively deliver disk data to an Atari. Importantly, FujiNet confirms that the Atari’s serial bus can tolerate the slight latencies of network storage, as FujiNet’s network disk (N: device using TNFS) is regularly used without issue. The FujiNet documentation and forum discussions can guide how to implement SIO protocols in firmware and how to structure a multi-device server that the Atari will communicate with. In summary, FujiNet is a cornerstone project proving that ESP32 + Atari SIO + Wi-Fi + disk images is not only possible but extremely useful​
TINKERDIFFERENT.COM
. Astarta-ESP32 (ESP32-based Drive/Tape Emulator): Astarta-ESP32 is another open hardware project that specifically emulates Atari storage devices. It provides four virtual disk drives (D1–D4 with read/write), a cassette tape emulator (read-only), and a real-time clock for Atari 8-bit computers​
GITHUB.COM
​
GITHUB.COM
. The second version of Astarta uses an ESP-WROOM-32 (ESP32) as the core, replacing an earlier Arduino Due-based design​
GITHUB.COM
. An SD card module is used for storage, and the ESP32 manages FAT32 file access to mount disk images. Astarta includes a small TFT display and buttons for local control (selecting images, etc.), plus it can connect to Wi-Fi for auxiliary functions​
GITHUB.COM
. Notably, Astarta’s firmware supports popular Atari disk image formats (ATR, XFD), including large 16MB ATR disk images, and even has partial support for protected formats (PRO) and a pseudo-XEX mount that creates a temporary disk for a single executable​
GITHUB.COM
. It also implements a built-in FTP server over Wi-Fi to allow management of the SD card contents from a PC​
GITHUB.COM
 – showing a practical way to update disk images without removing the card. While Astarta is primarily a single-computer drive emulator (one Atari connected to one ESP32 device), its hardware and firmware are relevant. It proves that an ESP32 has enough performance to handle four virtual drives plus a tape concurrently on the SIO bus, and it provides concrete examples of SIO command handling, sector read/write implementation, and image file parsing. Its use of Wi-Fi is mostly for time sync and remote file management​
GITHUB.COM
, but one could extend this to networking multiple machines. For our project, Astarta-ESP32 serves as a reference for building an SD-based disk emulator on ESP32 and underscores the importance of proper 5V-to-3.3V interfacing (it uses simple resistor level shifters and notes the need for a 3.3V regulator when powering from Atari’s 5V line​
GITHUB.COM
). Astarta’s source code (available on GitHub) will be useful for implementing ATR image mounting and SIO command processing on the ESP32 side of our system. SIO2SD and SDrive (Standalone SD Card Disk Emulators): Before Wi-Fi-enabled devices, Atari hobbyists created standalone disk drive emulators using microcontrollers and SD cards. SIO2SD is a well-known device that allows loading software on Atari 8-bits via the SIO port from an SD card​
LOTHAREK.PL
. It typically uses an AVR microcontroller and presents itself as one or more disk drives, reading ATR (and other format) images from the SD. SIO2SD often includes an LCD and buttons to select disk images, and it adheres to Atari’s SIO protocol to emulate a floppy drive (usually device #1). It’s a proven solution for a single Atari, and multiple SIO2SD units could be used independently – but it doesn’t natively network the Ataris together. However, the firmware (which has been refined over years) is a valuable resource for understanding timing constraints of SIO and how to respond to commands like READ, WRITE, format, etc. Similarly, SDrive and its popular variant SDrive-MAX are Arduino-based floppy/tape emulators. The SDrive-MAX uses an Arduino Uno/Nano (ATmega328p) with a touchscreen or OLED, running the open-source sdrive-ng firmware ported to Arduino​
ATARI8BIT.NET
. It can emulate up to four disk drives plus a cassette, using a FAT32 microSD card to hold disk images​
ATARI8BIT.NET
. Projects like SDrive-MAX demonstrate that even an 8-bit microcontroller at 16 MHz can handle the Atari SIO bus in real time and manage multiple virtual drives. This bodes well for using an Arduino Nano as the Atari interface in our project – the Nano (ATmega328) is of similar capability. From SIO2SD/SDrive, we glean that precise timing and cycle-accurate handling of SIO signals is possible on Arduino, but also that limitations exist (e.g., handling very high-speed SIO mods might be beyond an 8-bit MCU, whereas ESP32 can handle them more easily). These projects usually don’t incorporate networking, but they lay the groundwork for robust disk emulation firmware on microcontrollers. Atari Wi-Fi Modems (ESP8266-Based Modem Emulators): Another class of relevant projects are Atari “Wi-Fi modems” which emulate the Atari 850 serial interface and modem, allowing an Atari to dial out to Telnet BBSes over Wi-Fi. One example is the Atari WiFi Modem (#AtaWiModem) project, which provides full Atari 850 interface emulation (the R: handler) on an ESP8266/ESP32​
FORUMS.ATARIAGE.COM
. It boots a device handler on the Atari and works with standard terminal software as if an 850 interface and phone modem were present. The ESP8266 is used to handle the actual telnet/Internet side and present an AT command set to the Atari. While this is focused on telecommunications rather than disk storage, it is instructive for networking multiple Ataris. If each Atari in our networked disk system had a Wi-Fi enabled interface (similar to a Wi-Fi modem), they could all connect to a central hub over a wireless LAN. In fact, FujiNet’s initial modem implementation is part of its multi-device set – FujiNet can act as a modem so Atari terminal programs communicate through its ESP32 to the Internet​
TINKERDIFFERENT.COM
. The existence of these modem projects confirms that ESP8266 or ESP32 can directly interface with Atari SIO (via level shifting) and handle wireless communication. It also provides sample code for networking (esp8266 AT command emulation) and for how an Arduino/ESP might be programmed to handle SIO bytes and convert them to TCP/UDP packets. We can adapt similar principles for disk data transfers. SIO2IDE and Hard Disk Interfaces: Historically, enthusiasts also connected Atari 8-bits to hard drives. SIO2IDE was one such project which connected IDE/ATA hard disks or CompactFlash cards to the Atari SIO bus using an AVR microcontroller (e.g., AT90S8515 or ATmega8515) as the translator. The SIO2IDE interface, developed in the early 2000s, could act as a disk drive device and allowed large storage (relative to floppies) to be used by the Atari​
REALDOS.NET
​
MATHYVANNISSELROY.NL
. Later firmware versions of SIO2IDE supported two drives (master/slave on the IDE bus) and up to two SIO2IDE devices on one Atari (via SIO chain addressing)​
REALDOS.NET
​
MATHYVANNISSELROY.NL
. Although SIO2IDE did not network multiple computers, it demonstrated the feasibility of using a microcontroller to interface parallel ATA (or CF) storage to the Atari. For our purposes, SIO2IDE’s design indicates how one might handle a different storage medium (IDE/SATA) via a microcontroller. Its source code and schematics (now open-sourced​
GITHUB.COM
) can guide how to implement low-level sector reading and writing, how to deal with partitioning (it had companion PC and Atari software for partition configuration), and how to optimize data transfer over the slow SIO link (for instance, possibly using burst modes or caching). The existence of SIO2IDE suggests that if an ESP32 had a way to connect a SATA or PATA drive (perhaps via a bridge or SPI interface), one could incorporate that. However, SD cards are far more common today and easier to interface. Nonetheless, lessons from SIO2IDE (and similar PBI hard-disk interfaces like MyIDE, IDE Plus, SIDE cartridge) include managing multiple partitions, ensuring compatibility with DOS filesystems (SpartaDOS, MyDOS, etc.), and providing configuration tools for the Atari to recognize the mass storage. Networking Multiple Atari Computers: In the past, there was no official Atari 8-bit network for sharing disks among multiple computers concurrently. Each Atari was a bus master on its own SIO chain, so connecting two computers to one drive was not feasible with stock hardware. However, in modern implementations like FujiNet, the concept of multiple Ataris sharing a server has emerged at the software level: e.g., several Ataris each with a FujiNet can all connect to the same TNFS (Trusted Network File System) server over Wi-Fi to access disk images. TNFS, originally developed for the ZX Spectrum community, is a lightweight network filesystem. FujiNet adopted it to allow disk loading via Wi-Fi; users can run a TNFS server on a PC or Raspberry Pi (or use public ones) and store ATR images there​
CTRL-ALT-REES.COM
. This effectively networks the Atari drives – if two Ataris open the same file on a TNFS server, they are conceptually sharing that disk (though without awareness of each other at the DOS level). The FujiNet emulator bridge project even implements a “NetSIO” hub where an Atari emulator and a physical FujiNet device share a virtual SIO bus over UDP​
GITHUB.COM
. This is essentially networking at the signal level – it packages SIO signals into UDP datagrams to route between an emulator and hardware FujiNet. Such innovations hint at how one might design a protocol for a central SIO hub. In summary, while historical attempts at multi-Atari networking were scarce, current projects illustrate approaches to share storage: using a central server (like TNFS over Wi-Fi) or a hub that relays SIO commands across network links​
GITHUB.COM
. These will inform our communication architecture for the Arduino-based interfaces and the ESP32 hub.
Technical Hardware & Schematics
Designing the hardware involves two primary aspects: 1) interfacing the modern microcontrollers (ESP32/ESP8266/Arduino) with the Atari’s SIO or PBI ports, and 2) connecting suitable storage media (SD, CF, SATA) to the ESP32 hub. Each connection demands level shifting and attention to electrical limitations, as well as timing alignment. Atari SIO/PIO Interface (Arduino Nano as Atari Adapter): The Atari SIO port uses 5V TTL signaling and a custom pinout for serial data and command signals. The Atari always acts as the master on this bus, issuing commands and clocking data, while peripherals (drives, etc.) respond as slaves​
FORUMS.ATARIAGE.COM
. Key signals include DATA IN (peripheral-to-Atari serial data), DATA OUT (Atari-to-peripheral data), COMMAND (Atari command strobe), as well as ground, +5V power, and some rarely-used control lines (Proceed, Interrupt, Audio, etc.)​
OSHPARK.COM
​
ALLPINOUTS.ORG
. To connect an Arduino (5V logic) or ESP32/ESP8266 (3.3V logic) to SIO, level shifting is required to avoid damaging the modern ICs and to meet logic threshold requirements. A practical example is a small level shifter board for Atari SIO that was designed to interface an ESP8266 module to the SIO lines​
OSHPARK.COM
​
OSHPARK.COM
. It uses simple MOSFET-based bi-directional level translators (DMG2302 MOSFETs with 10K resistors) to step down the 5V signals on Data-In, Data-Out, and Command to 3.3V, and likely also to allow the 3.3V device to drive the lines to a 5V-compatible level​
OSHPARK.COM
​
OSHPARK.COM
. This board fits into the SIO jack and was reported to successfully connect an ESP-01 (ESP8266) to an Atari 400 – even powering the ESP8266 from the SIO’s +5V supply via a 3.3V regulator​
OSHPARK.COM
​
OSHPARK.COM
. We can leverage this design for our Arduino Nano interface: since the Nano runs at 5V, fewer level shifts are needed when using it directly on SIO (the Nano’s 5V TTL can interface Atari signals directly for input/output). However, if we include an ESP8266 on the same adapter (for Wi-Fi connectivity), those lines to the ESP8266 must be shifted to 3.3V. In either case, the Command, Data In, Data Out lines should be handled as open-collector style (the SIO bus expects that multiple devices could pull Data In line, etc., so devices usually use transistors/MOSFETs and resistors to avoid contention). Schematics from FujiNet hardware show the use of FETs or transistor drivers on these lines – for example, FujiNet uses BSN20 transistors for level shifting on SIO signals in one revision (according to discussions, to prevent bus interference when the device is off)​
GROUPS.GOOGLE.COM
. In our design, each Arduino Nano will connect to an Atari’s SIO. The Nano’s UART or GPIO will handle the serial bytes, but note that Atari SIO is bit-banged and has specific timing (it’s not exactly RS232 – it’s a clocked serial protocol at ~19200 baud with sync bytes). The Arduino will likely need to use precise cycle timing or an SPI/UART in synchronous mode to capture and send bits. Projects like SDrive-MAX (Arduino-based) prove it’s possible with careful coding. At the electrical level, aside from logic level shifting, we must consider power: The Atari SIO provides +5V out, but it is limited (approx 500 mA total for all devices). Each Arduino Nano and attached ESP8266 should draw as little as possible, or use external power if available. The OSH Park project noted that an Atari 400’s 5V could power an ESP-01 module with regulator, but that’s probably near the edge for multiple devices​
OSHPARK.COM
​
OSHPARK.COM
. We might design our interfaces to take power from an external source or the central hub, especially if multiple Ataris are connected (to avoid overloading any one computer’s supply). In summary, the Atari interface hardware will include an SIO plug, level shifting circuitry (potentially just a few resistors/MOSFETs as in Astarta – which used resistor dividers for 5V to 3.3V conversion​
GITHUB.COM
​
GITHUB.COM
), and an Arduino Nano with optional Wi-Fi module. For PBI/ECI (Parallel Bus Interface on XL/XE), the approach would differ since PBI is an interface to the system bus, but the question focuses mainly on SIO, which is simpler and available on all models. ESP32 Central Hub Hardware (Storage Interface): The central hub will be built on an ESP32 (e.g., an ESP32 DevKit or module). The ESP32 will manage the main storage device holding all disk images/partitions. Three storage interface options were mentioned: SD card, CompactFlash (CF), or SATA drive. Each has different hardware needs:
SD Cards: Easiest to interface – ESP32 has an SPI bus (or SD/MMC host interface on some pins) that can directly connect to an SD card socket. As seen in Astarta-ESP32, the SD card was wired to the ESP32’s VSPI pins (IO23 MOSI, IO19 MISO, IO18 SCK, IO5 CS) with appropriate 3.3V power​
GITHUB.COM
. If the SD module has its own level shifter or regulator, one must ensure the ESP32 feeds it 3.3V (Astarta notes using 5V for an SD adapter that had an onboard regulator, but warns to use 3.3V if not, to avoid damage​
GITHUB.COM
). For our design, an SD card offers a simple, FAT32-compatible storage that can easily hold many ATR files or even large HDD images. SD capacity (gigabytes) far outstrips Atari’s needs, and multiple Ataris could share files on one card. The ESP32 can handle simultaneous file access (its RTOS and dual-core nature allow multitasking), though the code must guard against race conditions if two clients request data from the SD at once.
CompactFlash (PATA): CF cards have an ATA parallel interface which could, in theory, be bit-banged or connected via the ESP32’s IO pins (which would require ~16 data lines plus control lines) – this is not very practical on an ESP32 due to pin count and timing constraints, but it was done on older AVR projects (like MyIDE or SIO2IDE used AVR’s parallel ports to talk ATA). If CF were required, a better approach might be to use a small IDE-to-SD or IDE-to-Flash bridge and treat it like an SPI device. However, since SD can achieve the same end result, CF would likely only be chosen if one wanted to directly use existing CF cards from other Atari interfaces. Given the complexity, CF is less attractive for the ESP32 hub; we’d likely stick to SD or an SSD via USB.
SATA Drives: Direct SATA interfacing is beyond the capability of microcontrollers like ESP32 (SATA is a high-speed serial protocol requiring dedicated controller logic). To use a SATA disk or SSD, one would typically incorporate a USB-to-SATA bridge or a dedicated SATA controller chip. The ESP32 (original series) doesn’t have a USB host interface (the newer ESP32-S2/S3 do have USB OTG which might act as host). If we were to integrate a SATA drive, a possible hardware path is to use an ESP32-S3 and a USB-SATA adapter IC or even a Raspberry Pi Pico (RP2040) acting as a USB host to the drive and then feeding data to ESP32 – this gets complicated. Another approach is to use a small single-board computer or a more powerful microcontroller for the hub. However, for the scope of this project (ESP32-based), the most practical storage is an SD card or a microSD on the ESP32. It provides ample speed (SPI at a few MHz is enough for 19k baud throughput many times over) and is simpler to wire and program.
Circuit Considerations – Timing and Signal Integrity: The Atari SIO operates at ~19,200 baud by default​
ALLPINOUTS.ORG
, which is slow, but it requires precise timing for acknowledging commands and data bytes (each byte is framed by a command/acknowledge handshake). The Arduino Nano, running at 16 MHz, can service this in software (SIO2SD proves this). Still, any level shifting should not add significant propagation delay or distortion. Using MOSFET-based level shifters (as in the OSH Park design​
OSHPARK.COM
) ensures fast switching and bi-directionality for open-collector lines. Simpler voltage divider resistors (as Astarta did for some lines​
GITHUB.COM
) may suffice for one-directional level downshift (e.g., Atari’s 5V output into ESP32 input). We must also consider the SIO bus idle and pull-up conditions: On Atari, some lines are pulled up internally or by devices. For instance, the DATA IN line is typically held high via a resistor network in devices. When our Arduino/ESP interface is attached, it should either actively drive or open-circuit appropriately. In FujiNet’s hardware, when the device is off, they ensured it doesn’t load the bus by using FETs that isolate when unpowered​
GROUPS.GOOGLE.COM
. In our multi-interface scenario, each Arduino should only drive its own Atari’s bus and not affect others – since each Atari is electrically separate, there’s no direct electrical interaction (they’ll only meet at the central hub via logic messages). So bus isolation is mainly a concern per Atari, not across the network. PBI/ECI Option: If using the Parallel Bus Interface (PBI) on Atari 600XL/800XL or the Enhanced Cartridge Interface (ECI) on 130XE, one could achieve faster data transfer (8-bit parallel) and avoid the slow SIO. There have been PBI hard disk interfaces (e.g., MIO, Black Box, SIDE cartridge uses the ECI/Cart interface to access CF). However, designing a PBI device is significantly more complex (it involves bus arbitration with the CPU, responding to DMA or IO requests at the clock cycle level). For simplicity, our design sticks to SIO – it’s the lowest common denominator and requires less intricate logic. The hardware then remains Arduino-level simple and doesn’t need fancy CPLDs or bus buffers that a PBI interface would need. Power from PBI/ECI could be higher (they often supply 5V/12V), but again, it ties one to certain models only. In summary, the hardware setup will consist of multiple Arduino Nano based SIO adapters (each with an SIO plug, minimal level shifting components, and possibly an ESP8266 or WiFi module) and one ESP32 hub (with an SD card slot and optionally USB if needed). Level shifting and voltage regulation are critical: ensure all microcontrollers run at compatible logic levels (likely use 3.3V for ESP8266/ESP32 and 5V for Arduino, with interface circuits between them). Schematics from projects like FujiNet and Astarta can be directly reused for parts of this: for example, FujiNet’s open hardware schematics detail transistor connections for SIO lines and how to wire the ESP32 to an SD card and to an ATmega128 (FujiNet used a small ATmega for device config/storage in early versions). Our design can be simpler – each Arduino replaces the need for an ATmega co-processor since it is itself the co-processor at the Atari side.
Software/Firmware Implementation
The firmware is the heart of this system – we need code on the Arduino Nanos to handle Atari SIO disk protocols in real-time, and code on the ESP32 hub to manage multiple connections, file access, and possibly networking. Fortunately, we have open-source examples to draw from: Arduino Nano Firmware (Atari Interface): Each Arduino’s firmware will emulate one (or more) Atari disk drive devices on its SIO port. At minimum, it should implement the standard Atari Disk Protocol (as used by Atari 810/1050 drives and later DOS). This involves responding to commands like Read Sector, Write Sector, Status, Format, etc., which are issued as command frames over SIO. The structure (from Atari’s perspective) is a command frame [device ID, command byte, aux bytes, checksum] that the drive must ACK, then data transfer, then a completion ACK. Timing is critical: the Arduino must detect the COMMAND line from the Atari (indicating start of a frame) and then read incoming bytes on DATA OUT, reply on DATA IN promptly, etc. Implementing this in Arduino C++ might involve using pin-change interrupts or tight polling loops to sense line changes. Projects like SDrive have code for this in AVR assembly/C – porting that logic to Arduino (which is AVR-based) is feasible. The Arduino can leverage its UART in synchronous mode if configured, but more commonly, implementations bit-bang the SIO protocol to have full control. We can reference SDrive-MAX firmware (sdrive-ng)​
GITHUB.COM
 and SIO2SD firmware to see how they handle SIO. In those, the microcontroller maintains state machines for listening for commands and for sending sector data from an image. For our design, the Arduino doesn’t store the disk data locally (no SD card on the Arduino in this plan); instead, on receiving a command (say “Read sector X from D1:”), the Arduino should forward that request to the ESP32 hub and wait for a response with the sector data, then send it to the Atari over SIO. This means the Arduino’s firmware has two roles: act as an SIO device to the Atari and act as a client to the ESP32 hub (via whichever link we choose, e.g., serial or Wi-Fi). To maintain real-time performance, the Arduino should probably have a buffer for one sector and minimal logic – essentially just bridging Atari <-> Hub with maybe a tiny cache. Because the SIO bus is slow (a 128-byte sector at 19.2k baud takes ~70ms including handshakes), the Arduino has some tens of milliseconds to get the data from the hub. If the hub responds within, say, a few milliseconds over a fast link, the Atari won’t notice a delay. If not, the Arduino might need to use the SIO acknowledge/busy mechanism to stall. The Atari DOS typically waits for an ACK or data until a timeout (a few seconds), so slight delays are acceptable. Some drives assert the PROCEED line or simply delay ACK to signal busy, but per Atari docs, official drives didn’t use the proceed/interrupt lines​
ALLPINOUTS.ORG
 – still, our emulation could insert dummy wait states if needed by delaying the ACK byte. For writing data, the Arduino would receive a sector from Atari and then forward it to the hub for storage. Ensuring reliability (checksum) and returning appropriate status (error codes if any) will be necessary for DOS to behave. We can use open-source Atari DOS handlers as reference for expected responses (e.g., how SpartaDOS or MyDOS formats send test writes, etc.). Additionally, since we want possibly multiple drives (D1, D2, etc.) per Atari, the Arduino can listen for commands addressed to device #1, #2, etc., and handle each (FujiNet and SIO2SD both emulate multiple drives by responding to multiple device IDs). The Arduino can advertise (to the hub) which drives are active or which images it wants to mount. ESP32 Hub Firmware: The ESP32 will run the central server coordinating disk image access. This firmware will maintain a list of available disk images/volumes (perhaps loaded from an SD card directory or a predefined set of partition images). It will communicate with each Arduino adapter using a custom protocol. If using Wi-Fi, we might implement a simple TCP or UDP protocol: for example, each adapter opens a socket to the ESP32 (if the ESP32 is in AP mode, it can accept connections). The protocol can be as simple as: Arduino sends: “<ID><Drive><CmdType><Sector>…” and ESP32 replies with the requested data or acknowledgement. We could model it on SIO2PC-PC communication, where the PC program (APE or RespeQt) receives an SIO command from an interface and responds with a sector from a disk image. In fact, this is analogous to well-known PC-side SIO emulators: the Arduino in our case acts like the SIO2PC interface cable, and the ESP32 hub acts like the PC running a disk server. There is existing PC software (e.g., RespeQt, AspeQT, APE) that might have defined protocols for SIO over serial. However, since we control both ends, we can design a lightweight protocol or even use an existing one like FujiNet’s NetSIO (over UDP)​
GITHUB.COM
. NetSIO was designed to carry raw SIO signals, but we could simplify and carry high-level commands instead. The hub firmware needs to manage concurrent access: if two Arduinos ask for data at the same time, the ESP32 (being multi-threaded) can handle them, but if they target the same file, we must synchronize file read/write. Using FreeRTOS on the ESP32, one task per client or a common loop that handles requests sequentially can be used. The SD card access library (ESP32 Arduino SD or SPIFFS) should be guarded by mutex if multi-tasking. For simplicity, a single-threaded message loop on the ESP32 that processes one request at a time (very quickly) might suffice given the low request rate (even 8 Atari units at full tilt 19k2 is only ~20 KB/s aggregate). The firmware should also implement any high-level logic like mounting images or partitioning. For example, we may allow the Arduino to send a “Mount image X as D1” request – the hub then opens that ATR file and associates it with that client’s drive 1. Or we pre-configure which image corresponds to each drive for each client. Including such commands would make the system flexible (similar to how SIO2SD lets you select images via buttons, we could remote-control via a simple menu interface on each Atari or even a PC tool). The ESP32 could also host a small web interface or telnet console to configure which ATR images are in each virtual drive slot for each connected Atari. That’s an extra feature beyond core functionality, but worth considering given ESP32’s capabilities. In terms of existing code references:
FujiNet Firmware: FujiNet’s firmware (PlatformIO C++ project on GitHub) already handles ATR/XFD image reading, and communicates with the Atari via SIO. However, FujiNet’s design is single-device (one Atari) per ESP32, and it integrates the SIO handling and networking in one. We can still borrow code for FAT filesystem, ATR parsing, and perhaps the disk device state machine. FujiNet’s code also includes a TNFS client to fetch remote files – in our case we want essentially a TNFS server on the ESP32. If our hub were to use TNFS protocol, FujiNet adapters could connect to it out-of-the-box. But since we plan custom Arduino adapters, we’ll use a custom simpler protocol.
Astarta-ESP32 Code: As noted, Astarta supports ATR and implements read/write to SD. We can examine how it creates files, writes sectors (ensuring to update checksums on ATR if any, etc.), and deals with edge cases (like partial last sectors in ATR). It also mentions supporting SpartaDOS’s APE TIME protocol for RTC​
GITHUB.COM
 – this could be a bonus to emulate a real-time clock device if needed (SpartaDOS can get time from an emulated drive with APE protocol).
SIO2PC and AspeQT: There is a simple open protocol called SIO2PC (used by older PC cable setups) where the Atari sends the command, and the PC sends back data. In our case, the Arduino and ESP will emulate a similar host-target relationship. Some implementations like AtariSIO Linux driver​
FORUMS.RASPBERRYPI.COM
 or RespeQt’s source could have insight on framing and error handling.
Disk Image Formats & Partitioning: The ATR format is the most common for Atari disk images. It has a 16-byte header and then sector data. ATR supports up to 16MB (65535 sectors of 128 bytes, or larger sector sizes for high-capacity ATR). Our firmware should be able to handle ATR images of floppy disks (90KB, 130KB, 180KB, 360KB, etc.) and hard disk images up to 16MB. If we want to exceed 16MB per “drive”, we could implement an emulation of multiple 16MB partitions presented as D1:, D2:, etc., or adopt the modern APT (Atari Partition Table) scheme: some hard disk interfaces (like SIDE) use a special partition table and present a device with multiple 16MB partitions selectable by the driver. However, implementing APT might be complex; a simpler route is to just treat each ATR or image file as one drive device. The hub can store many ATR files on SD (the filesystem can be FAT32 which supports large files and long names). The choice of storage format is important: storing raw ATR files on FAT32 is straightforward and leverages PC tools (the SD can be read on a PC to add files). This is what SIO2SD and SDrive do – they require the card be FAT16/32 and just navigate the directory to pick an image. Astarta also did this and even allowed long names as long as the card is FAT32​
GITHUB.COM
. Alternatively, we could have the entire SD act as one big Atari hard disk (with its own internal filesystem like SpartaDOS X’s FAT) – but that would complicate sharing and file loading. It’s better to use a standard FS on the SD and manage images as files. We should ensure the firmware can handle subdirectories if many images are present (perhaps fixed paths for each station). Handling 16MB Limits: Many Atari DOS (SpartaDOS X, MyDOS 4.5, etc.) support 16MB max per partition. To give an Atari more space, usually multiple drives (D1..D8) are used or multiple partitions on a hard disk device that the DOS can switch between. In our networked scenario, if truly a “shared disk system,” we might have one large filesystem that multiple Ataris read/write. But since Atari DOS doesn’t support multi-user access or partitions >16MB natively (without custom drivers), a pragmatic approach is: assign each Atari its own disk image or partition(s), or if sharing, limit to read-only for secondary users. The firmware could enforce single-writer, multiple-reader access to an image. For example, if two Ataris mount the same ATR as D1:, one could be the “owner” (read-write) and others get a read-only view (perhaps by responding to write commands with a write-protect error). Alternatively, we could implement a rudimentary file-lock system if using a DOS that supports it (not likely in Atari DOS). These are design decisions: initially, we can assume independent images per Atari, and later explore true sharing. Performance Optimizations: Given SIO is relatively slow, the bottleneck will often be the bus, not the storage. A single sector (128 bytes) at 19.2k takes ~67ms, whereas reading 128 bytes from an SD card is on the order of microseconds once the card is initialized (maybe 100 µs). Even including Wi-Fi latency, a few milliseconds should suffice for a response. Thus, we have plenty of headroom. However, if an Atari uses high-speed SIO (some DOS or loaders can bump to 38.4k or 57.6k baud, or use turbo routines that skip some handshakes), the Arduino and ESP32 must handle faster turnaround. It might be wise to implement the standard SIO at 19k first (for maximum compatibility), then consider higher speeds. The ESP32 could also implement caching: if an Atari repeatedly reads sector X (e.g., directory sector), the hub can serve it from memory without hitting the SD each time. This could reduce latency slightly. But since the timescales are already small relative to SIO, caching is optional. More importantly, robust error handling (checksums, retry logic) should be in place – Atari SIO has a checksum byte in each frame, and our firmware should verify and only send ACK if correct. If a communication error happens on the Arduino-hub link (e.g., a Wi-Fi packet lost), the Arduino should time out and maybe signal a CRC error to Atari so it retries the sector. These edge cases ensure data integrity. To summarize the firmware plan: the Arduino code will heavily borrow from SIO drive emulator logic (SIO state machine, command parsing, sector buffering) and add a communication client to forward requests. The ESP32 code will borrow from disk image handling libraries (FatFS for SD, ATR image parser from FujiNet/Astarta) and implement a server listening to multiple clients, routing requests to file I/O. All of this will be developed in C/C++ (Arduino environment for Nano and likely Arduino-ESP32 or ESP-IDF for the ESP32). Open-source references (FujiNet, Astarta, SDrive, SIO2IDE) provide code for virtually every piece: from reading ATR and supporting enhanced disk formats (Astarta already planned support for ATX, PRO, etc. which we could integrate later​
GITHUB.COM
) to dealing with FAT32 and long filenames (Astarta and SDrive code handle that). By using and merging these implementations, we avoid reinventing the wheel and ensure compatibility with known Atari disk standards.
Network Architecture & Protocols
The network architecture connects multiple Atari-attached adapters to the central ESP32 hub. We have options for the physical layer: wired serial (UART/RS485) or wireless (Wi-Fi). Given the mention of ESP8266 and ESP32, a Wi-Fi-based network is likely the goal. Here’s the proposed architecture: Topology: The ESP32 hub can function as a Wi-Fi Access Point (AP) that the Arduino adapters connect to, or all devices join an existing Wi-Fi network. Running the ESP32 as an AP is convenient in a closed environment – it creates a private network for the Ataris. Each Arduino adapter would need Wi-Fi capability; since an Arduino Nano doesn’t have it built-in, we pair each with an ESP8266 (e.g., ESP-01 or NodeMCU module) or use an ESP32 in place of Nano. However, using an ESP32 for each Atari might be overkill (essentially that’s just FujiNet for each). The Arduino+ESP8266 combo can be cost-effective: the Arduino handles SIO, and communicates to ESP8266 via UART. The ESP8266 runs firmware (possibly ESP-AT or a custom client) that sends messages to the ESP32 hub over TCP/IP. Another approach is to skip the Arduino and try using ESP8266 alone to handle SIO, but the ESP8266 single-core might struggle with real-time SIO while managing Wi-Fi – not impossible, but timing could suffer. So we stick with offloading real-time tasks to Arduino and networking to ESP8266. Therefore, each Atari station has Arduino Nano <-> (serial) <-> ESP8266 (Wi-Fi). This is essentially how many DIY Wi-Fi modems are structured. The protocol between the Arduino and ESP8266 could be very simple, even plain text or binary frames, since both are right next to each other. Alternatively, one could flash the ESP8266 with the standard “AT Command” firmware and have the Arduino issue AT commands to connect to Wi-Fi and establish a TCP connection. This is a straightforward method but somewhat slow due to string parsing. A custom firmware on ESP8266 (that automatically connects to the known AP and opens a UDP socket to the hub, for example) would be more efficient. For conceptual clarity, let’s assume each adapter, once powered, connects to the ESP32 AP and establishes a persistent TCP socket to a server port on the ESP32 hub. The ESP32 hub, as server, can differentiate clients by the socket or an ID. We may assign each adapter an ID (maybe its Atari unit number or just use the socket index). The communication protocol can be a simple packet structure:
For instance: Request packet: [ClientID][Drive#][Command][Sector#][…] and Response packet: [ClientID][Drive#][Status][Data…]. Since the connection is point-to-point, we might not need ClientID inside the packet (the hub knows which socket it came from). Including it might make debugging easier though. We also need to accommodate non-sector data commands, like status requests or open/close operations. We can model it after SIO at a high level: e.g., when Atari sends a Format command, the Arduino will forward a “FORMAT” request to hub with drive number, and hub can create a new ATR file or clear sectors accordingly, then reply success which Arduino turns into a status OK to Atari.
Managing Concurrent Access: With multiple Ataris, it’s possible two request packets hit the ESP32 at nearly the same time. The ESP32, being multi-core, can handle Wi-Fi on one core and file I/O on another (or using FreeRTOS tasks). However, to avoid race conditions if both try to access the same file, a global lock per image file should be used. If the Ataris are mostly using separate images, then concurrency is not a big issue – the OS will handle scheduling file reads. If they share an image (for example, a “shared data disk”), the hub must serialize modifications. We may implement a simple file lock: when one client is in the middle of writing to a shared image, others either queue their requests or get a “busy” response. Since the Atari will retry on NAK or busy (it expects eventually to get the data), a short delay is okay. As noted, Atari SIO protocol does have handshake for each byte, but not a multi-second busy indicator except by not sending an ACK. However, the timeout on Atari end is on the order of 1 second for a sector read – if the hub can’t serve within that, the Atari will error. So we should design such that even concurrent access to the same image is resolved quickly (likely by just queueing the second request until the first is done; a 128-byte write vs read conflict would be resolved in <100ms, which is fine). Another strategy: if multiple Ataris truly share a disk and one is writing, perhaps lock out others until the operation completes (which is milliseconds). If two Ataris both write to the same file without coordination, the disk image could become corrupt at logical level (just like two PCs writing a shared disk without a network filesystem arbitrator). We can’t fully prevent that without building a whole networking filesystem on top of Atari DOS (beyond scope). So perhaps document that simultaneous writes to one image is not supported or will lead to undefined results. For more advanced use, one could imagine an Atari running a server OS (there were concepts like a network DOS, but nothing standard) – that’s beyond what we need to solve. Communication Protocol Choice: We could consider using an existing higher-level protocol like TNFS or even FTP between the adapters and hub, but those are file-level and would require writing a client on the Arduino which is heavy. A custom lightweight protocol tailored to disk blocks is simpler. The protocol could be as simple as:
Arduino to Hub: a one-byte command code (e.g., 0x52 for “read sector”, 0x57 for “write sector”, mirroring the Atari’s command bytes ‘R’=0x52, ‘W’=0x57), followed by drive number and sector number (2 bytes maybe, since ATR can have up to 65535 sectors). For writes, followed by the 128-byte data and a checksum maybe.
Hub to Arduino: for read, respond with a status byte (0 for OK or error code) and the 128-byte sector data; for write, respond with status (0 for OK, or error if e.g. disk is write-protected).
We should include some framing so that the packets can be delineated on the TCP stream (length field or fixed length). Using a fixed length for read and write requests is doable (read request is, say, 4 bytes; read response is 129 bytes; write request is 132 bytes including data; write response 1 byte). However, status commands or others might differ, so perhaps a simple header: [Command][Drive][Length][…data…].
Using TCP ensures delivery in order; we just need to be careful to accumulate full messages. We can also use UDP to reduce overhead – the NetSIO uses UDP for speed​
GITHUB.COM
. UDP would require the ESP32 to listen on a port and each adapter to send to it. Given our environment (likely not lossy or congested), UDP could work and has lower latency (no handshake per packet). But if a packet is lost, the Atari would time out as if the disk failed – it might retry the SIO, which would trigger a new packet. That’s acceptable. Still, implementing reliable receiving on UDP adds complexity, so probably TCP is fine for a few clients. Addressing Multiple Clients: The hub will keep track of each connected client and likely assign them a unique identifier (maybe just use their socket number or IP). We might need this if the hub wants to send an unsolicited message to a client (for example, telling all clients to refresh because an image changed). But normally, communication is request-response initiated by the Arduino/Atari side only, so it’s fine. One nice feature to consider: The hub might broadcast an initial configuration to each Arduino (like “here are the available drives and their image names”). The Arduino could potentially show that on a connected display or pass it to the Atari (though Atari doesn’t really have a method to list images unless we provide a utility program). Alternatively, the Atari operator can use a small config program to query the hub via the Arduino (maybe using a custom SIO command device that lists images). These are stretch goals. Handling Delays: As mentioned, occasional delays are tolerable, but we must ensure the Atari OS doesn’t timeout. For example, when an Atari boots from disk, it sends a series of sector reads for the boot sectors. If one of those delays too long, the boot will fail. We should aim for the hub to respond within tens of milliseconds to each request. The ESP32 can easily achieve this unless it’s busy serving many others or doing a lengthy flash write. Writing to SD card (FAT) can sometimes cause a brief stall (if the SD needs to erase a block, etc.). If multiple writes happen (e.g., saving files on two Ataris at once), the SD card might introduce a 100-200ms latency occasionally. This is borderline for Atari DOS (which might wait ~1 second then error). It’s unlikely to hit often, but to be safe, large writes (like copying a file that writes dozens of sectors sequentially) might benefit from caching or async handling. A solution is to have the ESP32 acknowledge the write to the Atari quickly (so the Atari moves on), but then actually commit it to SD a moment later – however, if power is lost or the Atari immediately reads back that sector, that could be problematic. Probably best to just write-through and hope modern SD cards are fast enough (most are). If using Wi-Fi, we should also account for connection setup time – but as we maintain persistent connections, this is a one-time cost at startup. Alternative Wired Network: While Wi-Fi is convenient, a wired approach could connect all Arduinos to the ESP32 via a multi-drop bus. For instance, the ESP32 has multiple UARTs; it could theoretically connect to up to 3 Arduino adapters via separate serial lines. If we wanted more Arduinos, we could use an RS485 bus (all devices on one differential pair) where each Arduino has an ID and the ESP32 polls them. This would be akin to a mini fieldbus. The protocol could be similar over UART. This could reduce complexity (no ESP8266 needed, no wireless issues). The trade-off is physical wiring and the number of ports. RS485 multi-drop with an addressing scheme is feasible – the ESP32 would send an address byte to specify which Arduino should listen. However, arbitration when an Arduino needs to send (when Atari issues a command) would need the Arduino to wait for a poll or signal the hub via a separate line or RS485 half-duplex scheme. It becomes complicated and custom – whereas Wi-Fi leverages existing networking stack and allows truly asynchronous communication. Since the question highlights ESP8266/ESP32, the wireless method is likely preferred. In conclusion, the network architecture will be a star topology with the ESP32 at the center. Communication will be via Wi-Fi (ESP32 acting as AP, ESP8266 clients). The protocol will carry disk-sector-level requests. By keeping the protocol stateless (each request self-contained) and simple, we ensure reliability. We will implement basic concurrency handling on the hub. The end result is effectively a tiny local area network of Atari disk interfaces, analogous to a file server in a PC network. Each Atari remains isolated in terms of bus (no direct SIO connection to each other, avoiding any multi-master conflicts). They only “share” data when the hub serves the same file to more than one. This architecture is scalable to as many clients as the ESP32 can handle sockets for (practically perhaps 4–8 clients, limited by Wi-Fi traffic and memory). It’s also flexible – new clients can join or drop without affecting others (the hub could detect a client disconnect and close its files).
Storage Media & File System Considerations
Choosing and managing the storage media on the central hub is critical for capacity and compatibility. We evaluate the options (SD, CF, SATA) and file system concerns: SD Cards as the Primary Storage: SD (or microSD) cards are highly suitable because they are flash-based (no moving parts), easy to interface with SPI, and large enough to hold hundreds of ATR images (even a 4GB card is massive in Atari terms). SD cards can be formatted with FAT32 or FAT16, which the ESP32 Arduino library (using FatFS under the hood) can mount. By using FAT32, we gain support for long filenames, directories, and large volume sizes. This is useful to organize images (e.g., separate folders per Atari or per project) and use descriptive names. As noted in the Astarta project, one should restrict file name characters to ASCII for simplicity, but spaces and long names are supported​
GITHUB.COM
. The hub can thus present a nice catalog of disk images. When the Atari requests a particular drive, the firmware will open the corresponding file on the SD. We should consider the overhead of opening/closing files frequently; it’s usually fine but perhaps keep files open if they’re in active use to reduce open/close calls (just ensure to flush writes). Another advantage of SD: it’s easy for a user to update – either via the hub offering an interface (like Astarta’s FTP server​
GITHUB.COM
) or by physically moving the card to a PC. The downside of physical removal is it interrupts all Ataris; thus, implementing a basic Wi-Fi file management (FTP or HTTP upload) on the ESP32 hub is useful for maintenance. We can incorporate an FTP server task as Astarta did, or a simple web-based uploader. CompactFlash/SATA considerations: CompactFlash cards, when used in “True IDE” mode, essentially act as an ATA hard disk. Interfacing one to an ESP32 would require 3.3V level shifting and using many GPIOs to bit-bang the bus, or a specialized interface chip. This is likely not worth the effort when SD can achieve the same outcome with less trouble. However, if for some reason a CF or IDE drive was preferred (say to directly use an old Atari hard disk image without conversion), one could attach an ATA-to-SPI bridge (some old chips exist that let microcontrollers talk to ATA drives over serial). Given the scope, we will not pursue CF/IDE in our initial design; instead, we note that if needed, a CF could be used by adding an ATA interface shield to the ESP32 and adapting SIO2IDE’s approach, but the complexity and large code overhead (ATA protocol handling) aren’t justified when ATR files on SD accomplish the same user experience. Using a SATA SSD/HDD: If extremely large storage or durability is needed, a small SATA SSD could be used. But as discussed, this would require a USB host on ESP32-S3 or a separate controller. A pragmatic approach, if someone wanted this, is to use a Raspberry Pi (running an Atari disk server program) or an SBC that has SATA and create a similar networking scheme. Since the question confines to ESP32/ESP8266/Arduino, we conclude that SATA direct usage is not practical. Instead, an SD card or even a USB flash drive (if ESP32 had USB host) is simpler. Another idea: one could plug the ESP32’s SD slot with a microSD-to-SD adapter that itself holds a microSD; this could allow using some SATA-to-SD converter (some products allow connecting an SD card slot to an SATA drive, essentially making the SATA appear as an SD – but those are rare and intended for specific controllers). In summary, we will go with SD as the storage medium. File System and Atari Format Constraints: The Atari 8-bit computers predominantly use their own filesystems (e.g., Atari DOS 2.0 FS, SpartaDOS FS) inside the disk images. From the perspective of our hub, these are opaque – we do not need to interpret the Atari filesystem; we operate at the sector level. So we don’t actually care if it’s FAT16 or proprietary inside the ATR – we just read/write sectors. However, when it comes to hard disk images, SpartaDOS X’s partitions (APT) or MyDOS partitions might come into play. If we wanted to emulate a single large hard disk device (like what SIO2IDE or SIDE presents), we might prefer to use one large image file that contains multiple 16MB partitions. The Atari-side driver (like FJC’s HDD driver for SIDE/SpartaDOS) could then access partitions. But supporting that requires understanding the partition table to direct reads to the correct offset. It might be simpler to let each partition be a separate ATR file (which is essentially what ATR hard disk images are: some ATRs are actually 16MB “partitions”). A possible scheme is to number drives D1-D8 and beyond such that, for example, a hard disk with 4 partitions could appear as D1-D4 each 16MB ATR. SpartaDOS X could mount D1: through D4: as partitions C, D, E, F for instance. This avoids implementing partition logic in our firmware. Each ATR then max 16MB. Only caveat: standard ATR header uses 16-bit for sector count which maxes at 65535 sectors of 128 bytes (~8MB). There is an extension for 16MB (with 256-byte sectors or double-density flag). We need to ensure our ATR handling code supports that (FujiNet’s FNEW explicitly can create 16MB disks​
FUJINET.ONLINE
, so presumably their code handles it). The optimal storage format therefore is to use ATR files (or possibly XFD for single-density disks, which are just raw dumps with no header). ATR is more flexible because of the header info, so we’ll likely stick to ATR for floppy and medium images. For very large images, another format like SDX image (SDX uses an 8MB partition image) or simply raw might be needed, but since ATR and others cover up to 16MB, we’re good. Data Integrity and Performance: Using FAT32 on the SD means that abrupt power loss could corrupt the FAT if writes were happening (like any storage). The ESP32 could mitigate this by flushing file operations immediately and perhaps using safe write practices. Because multiple Ataris might be writing, we should be careful not to keep the card mounted r/w all the time if not needed – but realistically we will because someone might issue a disk write anytime. So ensuring a proper shutdown or flush command (maybe triggered by user via a button on the hub) would be wise to tell all to pause and sync the filesystem. On performance, the SD card via SPI can usually do a few megabytes per second. Our worst-case aggregate from Ataris will be far less, so performance is fine. The latency of filesystem operations on a large FAT32 (say with thousands of files) might be noticeable when opening a file by name. If we have a huge image library, a simple linear search for a filename could take time. We can optimize by either expecting the user to provide the exact filename (so we do fopen directly) or maintain an index in memory of available images on startup. The hub could scan the SD card at boot and store a list. Then open operations are quick. However, an ESP32 has limited RAM, but a list of a few hundred filenames is trivial in size. If thousands of images, maybe use an SD cluster to store a directory for each Atari etc. Partitioning the SD for multiple uses: We might consider partitioning the SD card itself (e.g., one partition FAT32 for the image storage, another raw used directly as an Atari disk). But that complicates matters and isn’t needed if we use image files. FAT16 vs FAT32: FAT16 could be used if the card is smaller (<2GB) and some early microcontroller code only supported FAT16. But ESP32 uses FatFS which supports FAT32 easily, and FAT32 allows >2GB and more files, so FAT32 is recommended. Large File Support: If an Atari uses something like RespeQt’s hard disk emulation, it might want >16MB continuous (some people use like 64MB images by chaining partitions with drivers). ATR cannot go beyond 16MB (unless using OSS “SpartaDOS HC” concept, but that’s not standard). If needed, we could implement another container like a raw image plus an descriptor. But until a need arises, sticking to known limits is fine. Alternate Storage: Network or Cloud: Though not asked, one could conceive the ESP32 hub could itself fetch data from a network (like act as a cache for a NAS or something). Given the offline, embedded nature, we’ll assume all data is on the SD locally. However, hooking the ESP32 to an upstream server (like a central NAS via Wi-Fi) would basically make it a relay – not in scope now. In conclusion, we will use a single SD card on the ESP32 formatted as FAT32 to store all disk images (ATR, XFD, possibly CAS for tapes). The firmware will manage these files, ensuring compatibility with 8.3 and long names. We will support ATR up to 16MB, which covers floppy and hard disk partitions used in Atari world​
FUJINET.ONLINE
. The storage read/write performance will vastly exceed Atari’s needs, so the focus will be on integrity and ease of use. The system will effectively act like a file server where each Atari’s disk drive requests are translated into file reads/writes on the SD card. This provides a flexible and efficient solution, leveraging decades of Atari community knowledge on disk image handling and modern FAT file systems for manageability.
Implementation Roadmap
With the research and design considerations laid out, we can now form a concrete roadmap to build the ESP32-based central hub and the Arduino Nano-based Atari interfaces: 1. Hardware Prototyping:
Atari Interface (Arduino Nano + Level Shifters): Begin by building a single Atari adapter. Use an Arduino Nano and wire it to an Atari SIO connector (you can salvage one or 3D-print and use header pins as in the “Poor Man’s SIO” design). Include the minimal level shifting: e.g., a BSS138 or similar small MOSFET for each of the three main lines (Command, Data In, Data Out) with 10K resistors as pull-ups​
OSHPARK.COM
. Alternatively, since the Nano is 5V, you could directly connect Data Out (Atari to Arduino RX) and Command (Atari to a digital input) with simple resistive dividers (to drop 5V to ~3V for safety on Arduino’s input), and use the Arduino’s TX (5V) through a series resistor or transistor to Data In line of Atari. Test this interface by writing a simple Arduino sketch to listen for SIO traffic or toggle lines and observe on the Atari (or oscilloscope). Ensure that the Atari can power the Nano (via SIO 5V pin) or use external 5V if needed (connect Atari GND to common ground). Verify levels: when Arduino drives Data In low, it should register on Atari, etc. One can use Atari’s built-in SIO sound (for cassette) or other signals to test line control.
ESP8266 Integration: Connect an ESP8266 module (e.g., ESP-01) to the Arduino via UART (Arduino TX -> ESP RX, RX->TX, plus 3.3V regulator for ESP8266 and common ground). Flash the ESP8266 with AT firmware or a simple Wi-Fi client firmware if available (some projects might have ready-made firmware for Wi-Fi modems). For initial testing, use AT commands from Arduino to join a Wi-Fi network and open a connection to a test server. This verifies that the Nano<->ESP8266 link is working. Later, we will replace this with code that automatically connects to our ESP32 hub.
ESP32 Hub and SD Interface: Set up an ESP32 dev board. Attach an SD card breakout (if not built-in) to the ESP32’s VSPI or HSPI pins as per Astarta’s wiring​
GITHUB.COM
 (GPIO23 MOSI, 19 MISO, 18 SCK, 5 CS, plus 3.3V power and GND). Add a button or two for resets or future use (e.g., one could repurpose for safe shutdown or switching modes). Optionally, an LED can be added to indicate activity (blink on file access). If available, integrate a small 1.3" OLED to display status (like number of clients connected, etc.), though not necessary. Prepare a breadboard prototype of the ESP32 with SD and maybe one Arduino client to start.
PBI Option: (Optional, if exploring PBI later) – design a simple breakout for the PBI/ECI and level shifting buffers (74LS245 or 3.3V tolerant buffers) if ever connecting ESP32 directly. This likely will be shelved for now in favor of SIO.
2. Low-Level Firmware Development (SIO handling on Arduino):
SIO Protocol Implementation: Write the firmware for the Arduino Nano to emulate an Atari disk drive. As a first milestone, implement a minimal “Device Presence” and “Status” response. In Atari DOS, when it boots, it sends a “Get Status” command ($53) to each drive 1 through 4. The Arduino should recognize the command frame (which includes the device ID and command byte) and reply with an ACK then a status byte indicating it’s a disk drive with certain status (for example, bit indicating write protect or not, etc.). Use resources like Atari’s Device Protocol spec or existing emulator code to determine what bytes to send. For initial testing, hardcode a response that makes the Atari think drive #1 is present. Run an Atari (with a BASIC program or DOS) and see if it recognizes the drive. This can be tested by trying to boot (which will fail since no actual sectors yet, but the Atari should at least not say “Error 21” (no device) for D1:). Debugging can be done by connecting the Arduino to a PC and printing logs of what commands it sees.
Sector Read/Write Bridging: Next, implement the logic to handle READ and WRITE commands. At this stage, you might not have the ESP32 hub fully working, so you can simulate the hub by storing a dummy disk image in the Arduino’s flash or responding with a fixed pattern. For example, intercept a READ SECTOR command and just return an array of 0xFFs or a repeating sequence. This will let you test high-level flow with an Atari. Format a disk in Atari DOS and see if it attempts to write sectors – capture that on Arduino. Write might be trickier because we need to accept data then acknowledge. Focus on making the Arduino robust in timing: use direct port access to wiggle lines if needed, or at least ensure digitalRead/Write is optimized (possibly using PORTD operations on AVR for speed). The SIO bit timing at 19200 baud means ~52 microseconds per bit; Arduino can handle that, but using hardware UART in synchronous mode might be an option to explore for reliability. If needed, use assembly or tuning from SDrive code.
Interface to Hub Protocol: Once the Arduino can handle SIO commands in principle, integrate the code to forward these requests to the ESP8266 (and hence to ESP32). For now, perhaps simulate with serial to a PC: have Arduino send a simplified text like “READ,drive1,sector10” to the PC (acting as hub) and have PC send back “ACK,data…”. When this round-trip is working over serial, port it to communicate with ESP8266. If using AT commands, you might do: AT+CIPSEND= etc., which is clunky. Better, consider flashing ESP8266 with NodeMCU firmware and using serial to send it a custom message (like the ESP8266 is running a custom program that bridges serial to a UDP socket). This part might involve writing a small custom firmware for ESP8266 using the Arduino framework: essentially it listens on UART for a message, and sends that message over UDP to the hub IP, then waits for a UDP reply and forwards it back via UART. This offloads the heavy Wi-Fi from Arduino logic. If unfamiliar with ESP8266 coding, the simpler fallback is to use AT commands: the Arduino issues AT+CIPSTART to connect on startup, then for each packet uses AT+CIPSEND. This will introduce some delays, but maybe it’s acceptable. We can optimize later by moving to a custom firmware once the concept is proven.
Testing Single Client End-to-End: At this point, test one Arduino+ESP8266 with the ESP32 (which we’ll get to coding next). The goal is to be able to boot an Atari and load a small program or directory from an ATR stored on the ESP32. This will be a big milestone showing the entire chain works.
3. ESP32 Hub Firmware Development:
SD Card and File I/O: Using the ESP32 Arduino library, write a simple program to mount the SD card and list files. Ensure you can open an ATR file and read specific bytes. Test reading an ATR’s first sector and printing it. Use known ATR files to verify correctness (the first bytes of an ATR of DOS 2.5, for example, have known values). Implement an readSector(file, sectorNum, buffer) function that handles the ATR header offset (ATR sector 1 might start at file offset 16 or 0 depending on format). Many ATR images have 16 byte header; the code should detect or store header info (some ATRs encode sector size and count in the header). Use FujiNet or Astarta code as reference for ATR format parsing. Also implement writeSector(file, sectorNum, data) to update the file (be cautious to open file in read/write mode and keep track of file position). Initially, do this with one file and make sure data integrity holds (you can write a known pattern and inspect the ATR on PC).
Networking (Server) on ESP32: Decide on TCP vs UDP. Suppose we use TCP for reliability. Set up the ESP32 as a Wi-Fi Access Point (using WiFi.softAP(ssid, password)) and then create a WiFiServer listening on a port (say 9000). Accept connections and when a client connects, spawn a task or handle it in the loop. Because multiple clients can connect, use either the AsyncTCP library or manage sockets in a list. An alternative is to use ESP-NOW (Espressif’s proprietary peer-to-peer protocol) to talk to ESP8266s without a traditional network stack – but that has distance limitations and complexity, so standard Wi-Fi IP is fine. Implement a simple protocol parser: e.g., read bytes until you have a full request (based on a length header or fixed size). Then perform the requested action on the SD (read or write sector, etc.), then send back the response. The response should include a status (OK or error). Potential error conditions: file not found, out-of-range sector, etc., which could correspond to Atari SIO error codes (like Nonexistent Sector error). Map them appropriately or simply return a generic error and let the Atari see a CRC/NAK.
Multi-Client Handling: If using Arduino framework, you might do this in the main loop by checking server.hasClient() and then reading from each WiFiClient. Because the SIO requests are sequential per client (an Atari waits for response before sending next command), we can interleave serving them fairly. Just make sure one slow file operation doesn’t starve another client; if needed, break up long operations (but most operations are short). Use a simple round-robin or event-driven approach. Testing with one client will be first; then simulate a second by perhaps running a small client on a PC or another dev board. Confirm that two connections can be handled without conflict.
Disk Image Management: Provide a way for the ESP32 to know which image corresponds to which drive and which client. Simplest: give each client its own fixed set of files (like client1 -> D1.atr, client2 -> D1.atr, etc., based on IP or an initial handshake where the client says “I am Atari #2”). Another approach is dynamic: the client could send a command to mount a particular file. Possibly, use the drive number in the request to index a table of file objects for that client. For example, maintain a data structure: openFiles[clientID][driveNum] = File handle. When a read comes in for drive X, use that handle to read. The question is how to initialize those handles. We could have a configuration file or simply on connection, automatically open files named after the client (like “Disk1_Client1.atr”). But a more user-friendly way is to allow mounting via an Atari utility or via a PC interface. For MVP, we might just hardcode file names for testing – e.g., have a specific ATR that the Atari will boot from (perhaps a modified DOS disk). Later, we can implement a control protocol: maybe using a special SIO command device (like device $70 for example) to signal mount events.
Concurrent Write Safety: Implement file locks if needed: simplest, a mutex lock around each file access in code. If using Arduino, one can use xSemaphoreCreateMutex() (from FreeRTOS) to guard file operations, or just disable task switching briefly (not ideal). Given low load, a coarse lock (all file access single-threaded) is fine. Test by issuing simultaneous requests (two Ataris reading different parts of the same ATR) and verify the data remains consistent. For now, we might not fully simulate two Ataris writing to the same image, as that’s an edge case.
4. Integration & Testing:
Single-Unit Testing: Use one Atari with the adapter and the ESP32 hub running the firmware. Attempt common operations: boot from a DOS disk ATR, directory listing, loading a BASIC program, saving a file, etc. Debug any issues in the command/response sequence (use logic analyzer or instrument the code with logs). Ensure that writing data on the Atari actually alters the ATR file on SD (by checking the SD card on a PC or reading back in Atari). Fine-tune timing if the Atari shows errors – e.g., if timeouts occur, maybe the Arduino needs to respond faster or assert a line. Possibly adjust the inter-byte timing – the Arduino might need to insert wait states if the ESP32 hasn’t replied yet (some small delay might be necessary – we can experiment with short busy loops).
Multiple Ataris Testing: Introduce a second Atari station with another adapter. Connect both to the ESP32 (for Wi-Fi, have both join the AP). Turn on both Ataris and see that they both can perform operations. Try accessing different images concurrently. If possible, try a scenario of both reading the same shared image (e.g., a game disk) simultaneously – one might load a program, while the other also loads something from the same disk. Observe if both succeed. Then test a write scenario: one Atari writes to the shared disk while the other reads from it (e.g., one creates a file, the other does a directory listing). The second might not see the update until it re-reads directory (Atari DOS does not auto-refresh), but as long as no corruption occurs, it’s okay. Check that no crashes or data mix-ups happen at the hub.
Performance Measurement: Measure the load times or transfer rates. If using standard SIO, loading a 50KB file might take ~20 seconds normally; with our system it should be similar, maybe slightly longer if overhead exists. If it’s too slow, identify the bottleneck (perhaps the Wi-Fi latency or AT command overhead). Possibly optimize by switching to UDP or custom ESP8266 firmware to reduce chatter. If performance is acceptable and reliable, keep it simple.
Edge Cases: Test what happens if an Atari reboots or disconnects unexpectedly. The Arduino would stop sending requests – the ESP32 might keep the socket open. Implement a timeout to close it or detect disconnection (TCP will eventually signal closed). Similarly, if the ESP32 restarts while Ataris are on, the clients should reconnect. Possibly have the Arduino try to reconnect periodically if it loses contact. Implementing a heartbeat or reconnect attempt in Arduino firmware will improve robustness (e.g., send a ping every few seconds, if no response then reset the Wi-Fi module and reconnect).
5. Enhanced Features:
Disk Image Management Interface: Develop a simple means to select/assign disk images to drives. One idea: create a text config file on the SD that maps client IDs to image filenames. The ESP32 on startup reads this and pre-opens those files. Users could edit that file via PC or FTP. Another idea: implement a basic on-screen menu on the Atari: For example, define a custom SIO device (say “N:” or use the R: handler infrastructure) that when accessed from an Atari program, it lists images from the hub. The Atari user could then pick one to mount on D1:. This requires writing a small client program on Atari side – perhaps overkill. Alternatively, use the ESP32’s webserver: The ESP32 could run a small web page listing connected Ataris (by some identifier or IP) and allow the user to assign images to each drive via dropdown (populated by scanning the SD card). This would be a modern and user-friendly approach, though it requires using the ESP32’s web libraries and serving a page (which it can do). The web UI could also show a log of operations or throughput. Given time, this is a nice feature to add after core functionality is solid.
Support for Tape (CAS) and Printer: As future expansions, we could allow the Arduino to also emulate a tape drive (CAS file playback) or a printer (redirect P: output to a file or network). FujiNet already does these – but implementing them would require more device handling on Arduino (for cassette, handle the motor and data line differently, for printer, handle P: device protocol). It might be beyond our immediate needs, but the hardware (ESP32) could definitely store CAS files and feed them.
SpartaDOS Hard Disk Mode: Consider adding an option for a large continuous drive with multiple 16MB partitions. Perhaps by presenting D1: as a special device that spans images. If so, we might incorporate parts of the SIO2IDE firmware logic. But if our multiple ATR approach suffices for users, this may not be needed.
Security & Stability: Since this is a local setup, security isn’t a big issue, but ensure to use a Wi-Fi password or ESP-NOW to avoid random devices connecting. Also, test with various Atari models (800XL, 130XE, etc.) to ensure compatibility. If possible, test high-speed SIO (some DOS like TurboDOS or external accelerators). The Arduino code might need adjustments to handle 52K baud if those are used.
6. Documentation and Schematics:
Document the final wiring schematics: show the SIO connector pin mapping to Arduino pins and level shifting components; show the ESP32 connections to SD and any other peripherals. Provide a circuit diagram for the Arduino adapter (could even design a small PCB combining Nano, ESP8266, and SIO plug, along with the MOSFET level shifters). Also, draw a diagram of the whole network to illustrate how multiple Ataris link to the hub via Wi-Fi.
Clean up the code and write usage instructions (e.g., how to configure Wi-Fi SSID in the firmware, how to add disk images to the SD card, how to assign them to drives). Possibly include example config files.
Cite the sources used (as per this research) and give credit to FujiNet, Astarta, SDrive, etc., as this project stands on their shoulders.
By following this roadmap, one should be able to incrementally build the networked disk system. Each step (hardware interface, single-drive emulation, networking, multi-client coordination) builds on the previous, reducing complexity at any given stage. The end result will be a functional prototype where an ESP32 hub with an SD card serves disk data to multiple Atari 8-bit computers concurrently over a wireless network, effectively acting as a shared “file server” for these vintage machines. All along, leveraging the accumulated knowledge and code from existing projects will save development time and ensure compatibility with Atari’s quirks and limits.
